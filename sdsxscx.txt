"File_name": {
    "classes": {
        "name_of_class_1": {
            "content": "complete code of class 1",
            "method_declarations": {
                "name_of_method_decalration_1": {
                    "content": "complete code of method decalartion 1",
                    "dependencies": {
                        "invocation_expression_1": "json path of the file where this function's definition exists ",
                        "invocation_expression_2": "json path of the file where this function's definition exists"
                    },
                    "embedding_path": "embedding path of function 1"
                },
                "name_of_method_decalration_1": {
                    "content": "complete code of method decalartion 2",
                    "dependencies": {
                        "invocation_expression_1": "json path of the file where this function's definition exists ",
                        "invocation_expression_2": "json path of the file where this function's definition exists"
                    },
                    "embedding_path": "embedding path of function 2"
                }
            },
            "embedding_path": "embedding path of class 1"
        },
        "name_of_class_2": {
            "content": "complete code of class 2",
            "functions": {
                "name_of_method_decalration_1": {
                    "content": "complete code of method decalartion 1",
                    "dependencies": {
                        "invocation_expression_1": "json path of the file where this function's definition exists ",
                        "invocation_expression_2": "json path of the file where this function's definition exists"
                    },
                    "embedding_path": "embedding path of function 1"
                },
                "name_of_method_decalration_2": {
                    "content": "complete code of method decalartion 2",
                    "dependencies": {
                        "invocation_expression_1": "json path of the file where this function's definition exists ",
                        "invocation_expression_2": "json path of the file where this function's definition exists"
                    },
                    "embedding_path": "embedding path of function 2"
                }
            },
            "embedding_path": "embedding path of class 2"
        }
    }
}



code - 

from tree_sitter import Language as lang, Parser, Node
import tree_sitter_c_sharp
import json
import os  # Import the os module

# Load the C# language
CS_LANGUAGE = lang(tree_sitter_c_sharp.language())
# Initialize the parser with the C# language
parser = Parser(CS_LANGUAGE)

cs_file_content = """
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using GadgetsOnline.Models;
using GadgetsOnline.Services;
using GadgetsOnline.ViewModel;

namespace GadgetsOnline.Controllers
{
    public class ShoppingCartController : Controller
    {

        Inventory inventory;

        // GET: ShoppingCart
        public ActionResult Index()
        {
            var cart = ShoppingCart.GetCart(this.HttpContext);
            // Set up our ViewModel
            var viewModel = new ShoppingCartViewModel
            {
                CartItems = cart.GetCartItems(),
                CartTotal = cart.GetTotal()
            };
            // Return the view
            return View(viewModel);
        }

        public ActionResult AddToCart(int id)
        {            
            var cart = ShoppingCart.GetCart(this.HttpContext);

            cart.AddToCart(id);

            // Go back to the main store page for more shopping
            return RedirectToAction("Index");
        }

        public ActionResult RemoveFromCart(int id)
        {
            var cart = ShoppingCart.GetCart(this.HttpContext);
            int itemCount = cart.RemoveFromCart(id);\n            inventory = new Inventory();
            var productName = inventory.GetProductNameById(id);

            // Display the confirmation message
            var results = new ShoppingCartRemoveViewModel
            {
                Message = Server.HtmlEncode(productName) + " has been removed from your shopping cart.",
                CartTotal = cart.GetTotal(),
                CartCount = cart.GetCount(),
                ItemCount = itemCount,
                DeleteId = id
            };
            return RedirectToAction("Index");            
        }

    }
}
"""

code = cs_file_content
tree = parser.parse(bytes(code, "utf8"))

if tree is None or tree.root_node is None:
    print("Tree is None")
    exit()

root_node = tree.root_node
source_code_bytes = bytes(code, "utf8")
file_name = "ShoppingCartController.cs"  # Replace with actual file name

def extract_name(node: Node, source_code: bytes) -> str:
    """Extracts the name of a node.  Handles different node types."""
    if node.type == "method_declaration":
        # Find the identifier child
        for child in node.children:
            if child.type == "identifier":
                return source_code[child.start_byte:child.end_byte].decode("utf8")
    elif node.type == "invocation_expression":
        # Drill down to the method name.  This can be complex (e.g., chained calls)
        target = node.children[0]  # First part of the invocation
        while target.type == "member_access_expression":
            if len(target.children) > 2:
                target = target.children[2] # Get the right-hand side of the member access
            else:
                return None  # Handle cases where the member access expression is incomplete
        if target.type == "identifier":
            return source_code[target.start_byte:target.end_byte].decode("utf8")
    # Handle other cases or return a default value
    return None  # Or raise an exception if name is always required

def extract_class_info(class_node, source_code, file_path):
    """Extracts information about a class, including its functions and dependencies."""
    class_name_node = class_node.child_by_field_name("name")
    class_name = class_name_node.text.decode("utf8") if class_name_node else "UnknownClass"
    class_content = source_code[class_node.start_byte:class_node.end_byte].decode("utf8")
    class_info = {
        "content": class_content,
        "method_declarations": {},
        "embedding_path": f"embeddings/{class_name}.pt"
    }

    # Iterate through all descendants of the class node
    for descendent in class_node.descendants:
        if descendent.type == "method_declaration":
            function_name = extract_name(descendent, source_code_bytes)
            if function_name:
                function_info = extract_function_info(descendent, source_code, file_path)
                if function_info:
                    class_info["method_declarations"][function_name] = function_info

    return class_info

def find_method_declarations(node, source_code, file_path, method_declarations):
    """Recursively searches for method declarations within a node."""
    if node.type == "method_declaration":
        function_name = extract_name(node, source_code)
        if function_name:
            function_info = extract_function_info(node, source_code, file_path)
            if function_info:
                method_declarations[function_name] = function_info
    else:
        for child in node.children:
            find_method_declarations(child, source_code, file_path, method_declarations)

def extract_class_info(class_node, source_code, file_path):
    """Extracts information about a class, including its functions and dependencies."""
    class_name_node = class_node.child_by_field_name("name")
    class_name = class_name_node.text.decode("utf8") if class_name_node else "UnknownClass"
    class_content = source_code[class_node.start_byte:class_node.end_byte].decode("utf8")
    class_info = {
        "content": class_content,
        "method_declarations": {},
        "embedding_path": f"embeddings/{class_name}.pt"
    }

    # Find the body of the class (the part enclosed in curly braces)
    body_node = None
    for child in class_node.children:
        if child.type == "block":  #  "block" is the type for code blocks enclosed in {}
            body_node = child
            break

    if body_node:
        # Recursively find method declarations within the class body
        find_method_declarations(body_node, source_code, file_path, class_info["method_declarations"])

    return class_info

def extract_dependencies(function_node, source_code, file_path):
    """Extracts dependencies (invocation expressions) from a function."""
    dependencies = {}
    for descendent in function_node.descendants:
        if descendent.type == "invocation_expression":
            invocation_name = extract_name(descendent, source_code_bytes)
            if invocation_name:
                try:
                    invocation_code = source_code[descendent.start_byte:descendent.end_byte].decode("utf8")
                    dependencies[invocation_code] = file_path

                except Exception as e:
                    print(f"Error decoding invocation expression: {e}")
    return dependencies

def find_class_declarations(node, source_code, file_path, output):
    """Recursively searches for class declarations within a node."""
    if node.type == "class_declaration":
        class_name_node = node.child_by_field_name("name")
        if class_name_node:
            class_name = class_name_node.text.decode("utf8")
            class_info = extract_class_info(node, source_code, file_path)
            output[file_path]["classes"][class_name] = class_info
    else:
        for child in node.children:
            find_class_declarations(child, source_code, file_path, output)

def build_json_output(root_node, source_code, file_path):
    """Builds the JSON output in the specified format."""
    fileName = os.path.basename(file_path)
    output = {fileName: {"classes": {}}}

    # Find the namespace declaration
    namespace_node = None
    for child in root_node.children:
        if child.type == "namespace_declaration":
            namespace_node = child
            break

    if namespace_node:
        # Recursively find class declarations within the namespace
        find_class_declarations(namespace_node, source_code, file_path, output)
    else:
        print("No namespace declaration found.")

    return output

# Build the JSON output
json_output = build_json_output(root_node, source_code_bytes, file_name)

# Print the JSON output (or save it to a file)
print(json.dumps(json_output, indent=4))
